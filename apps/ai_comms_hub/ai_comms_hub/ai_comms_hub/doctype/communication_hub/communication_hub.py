# Copyright (c) 2025, VisualGraphX and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document
from datetime import datetime
import json


class CommunicationHub(Document):
	"""
	Master conversation record across all channels.

	Manages the lifecycle of a customer conversation from creation to closure,
	handling AI automation, human intervention, and cross-channel context.
	"""

	def autoname(self):
		"""Set the name of the document"""
		# Name is auto-generated by naming_rule: format:COMM-HUB-{#####}
		pass

	def before_insert(self):
		"""Before inserting new Communication Hub"""
		self.created_at = datetime.now()
		self.updated_at = datetime.now()

		# Set default values
		if not self.status:
			self.status = "Open"
		if not self.ai_mode:
			self.ai_mode = "Autonomous"
		if not self.priority:
			self.priority = "Medium"

		# Initialize counters
		self.total_messages = 0
		self.ai_messages = 0
		self.agent_messages = 0

		# Set platform-specific fields
		if self.channel in ["Facebook", "Instagram"]:
			self.within_24h_window = 1

	def validate(self):
		"""Validate document before save"""
		self.updated_at = datetime.now()

		# Channel-specific validations are optional to support various integrations
		# (n8n workflows, direct API calls, etc.)

		# Warn but don't block if recommended fields are missing
		if self.channel in ["Facebook", "Instagram"] and not self.social_sender_id:
			frappe.msgprint(
				_("Sender Platform ID is recommended for {0} channel").format(self.channel),
				indicator="orange"
			)

		# Check 24-hour window for Meta platforms
		if self.channel in ["Facebook", "Instagram"]:
			self.check_24_hour_window()

	def on_update(self):
		"""After update"""
		# Update statistics
		self.update_message_counts()

		# Update context if needed
		if self.total_messages > 0 and not self.context:
			self.generate_context_summary()

		# Check if conversation should be escalated
		if self.ai_mode == "Autonomous" and self.should_escalate():
			self.escalate_to_hitl()

	def before_submit(self):
		"""Before closing conversation"""
		if self.status not in ["Resolved", "Closed"]:
			frappe.throw(_("Cannot close conversation with status {0}").format(self.status))

		self.closed_at = datetime.now()

		# Generate final summary
		if not self.call_summary and self.channel == "Voice":
			self.generate_call_summary()

	def check_24_hour_window(self):
		"""
		Check if conversation is within 24-hour messaging window for Meta platforms.
		Facebook and Instagram restrict messaging to 24 hours after last customer message.
		"""
		if not self.created_at:
			return

		from datetime import timedelta
		time_since_creation = datetime.now() - self.created_at

		if time_since_creation > timedelta(hours=24):
			self.within_24h_window = 0

			# If trying to send message outside window, warn
			if self.ai_mode in ["Autonomous", "HITL"]:
				frappe.msgprint(
					_("This conversation is outside the 24-hour messaging window. "
					  "You may need to use a message template or wait for customer response."),
					indicator="orange",
					alert=True
				)
		else:
			self.within_24h_window = 1

	def update_message_counts(self):
		"""Update message count statistics"""
		messages = frappe.get_all(
			"Communication Message",
			filters={"communication_hub": self.name},
			fields=["sender_type"]
		)

		self.total_messages = len(messages)
		self.ai_messages = len([m for m in messages if m.sender_type == "AI"])
		self.agent_messages = len([m for m in messages if m.sender_type == "Agent"])

	def should_escalate(self):
		"""
		Determine if conversation should be escalated to human.

		Escalation triggers:
		- Negative sentiment detected
		- AI confidence below threshold
		- Explicit customer request for human
		- Complex function call failures
		- Compliance/legal keywords detected
		"""
		# Check sentiment
		if self.sentiment == "Negative":
			return True

		# Check RAG confidence
		if self.rag_confidence and self.rag_confidence < 60:
			return True

		# Check for escalation keywords in recent messages
		recent_messages = frappe.get_all(
			"Communication Message",
			filters={
				"communication_hub": self.name,
				"sender_type": "Customer"
			},
			fields=["content"],
			order_by="timestamp desc",
			limit=3
		)

		escalation_keywords = [
			"speak to human", "talk to person", "representative",
			"supervisor", "manager", "complaint", "lawyer", "legal"
		]

		for msg in recent_messages:
			content_lower = msg.content.lower() if msg.content else ""
			if any(keyword in content_lower for keyword in escalation_keywords):
				return True

		return False

	def escalate_to_hitl(self):
		"""Escalate conversation to Human-in-the-Loop mode"""
		self.ai_mode = "HITL"
		frappe.db.commit()

		# Create notification for agents
		self.notify_escalation()

	def notify_escalation(self):
		"""Send notification to available agents"""
		# Get users with Customer Support role
		agents = frappe.get_all(
			"User",
			filters={
				"enabled": 1,
				"name": ["in", frappe.get_all(
					"Has Role",
					filters={"role": "Customer Support"},
					pluck="parent"
				)]
			},
			pluck="name"
		)

		for agent in agents:
			frappe.publish_realtime(
				event="hitl_escalation",
				message={
					"hub_id": self.name,
					"customer": self.customer_name,
					"channel": self.channel,
					"sentiment": self.sentiment,
					"subject": self.subject
				},
				user=agent
			)

	def generate_context_summary(self):
		"""Generate AI summary of conversation context"""
		# Get all messages
		messages = frappe.get_all(
			"Communication Message",
			filters={"communication_hub": self.name},
			fields=["sender_type", "sender_name", "content", "timestamp"],
			order_by="timestamp asc"
		)

		if not messages:
			return

		# Build conversation text
		conversation_text = "\n".join([
			f"{msg.sender_type} ({msg.timestamp}): {msg.content}"
			for msg in messages
		])

		# Call LLM to generate summary
		try:
			from ai_comms_hub.api.llm import generate_summary
			summary = generate_summary(conversation_text)
			self.context = summary
		except Exception as e:
			frappe.log_error(f"Failed to generate context summary: {str(e)}")

	def generate_call_summary(self):
		"""Generate AI summary of voice call"""
		if not self.call_transcript:
			return

		try:
			from ai_comms_hub.api.llm import generate_summary
			summary = generate_summary(
				self.call_transcript,
				prompt="Summarize this phone call in 2-3 sentences, focusing on customer needs and resolution."
			)
			self.call_summary = summary
		except Exception as e:
			frappe.log_error(f"Failed to generate call summary: {str(e)}")

	@frappe.whitelist()
	def takeover(self, agent_user):
		"""
		Agent takes over conversation from AI.

		Args:
			agent_user (str): User ID of agent taking over
		"""
		self.ai_mode = "Takeover"
		self.assigned_to = agent_user
		self.status = "In Progress"
		self.save()

		# Notify the AI system to pause
		frappe.publish_realtime(
			event="conversation_takeover",
			message={
				"hub_id": self.name,
				"agent": agent_user
			}
		)

		return {"success": True, "message": "Conversation taken over successfully"}

	@frappe.whitelist()
	def handback_to_ai(self):
		"""Hand conversation back to AI from human agent"""
		self.ai_mode = "Autonomous"
		self.assigned_to = None
		self.save()

		frappe.publish_realtime(
			event="conversation_handback",
			message={"hub_id": self.name}
		)

		return {"success": True, "message": "Conversation handed back to AI"}

	@frappe.whitelist()
	def get_conversation_history(self):
		"""Get complete conversation history with messages"""
		messages = frappe.get_all(
			"Communication Message",
			filters={"communication_hub": self.name},
			fields=[
				"name", "sender_type", "sender_name", "content",
				"timestamp", "is_function_call", "function_name", "function_result"
			],
			order_by="timestamp asc"
		)

		return {
			"hub": self.as_dict(),
			"messages": messages
		}

	@frappe.whitelist()
	def add_message(self, content, sender_type, sender_name=None):
		"""
		Add a message to this conversation.

		Args:
			content (str): Message content
			sender_type (str): Customer, AI, or Agent
			sender_name (str, optional): Name of sender

		Returns:
			dict: Created message document
		"""
		message = frappe.get_doc({
			"doctype": "Communication Message",
			"communication_hub": self.name,
			"sender_type": sender_type,
			"sender_name": sender_name or sender_type,
			"content": content,
			"timestamp": datetime.now()
		})
		message.insert()

		# Update hub statistics
		self.update_message_counts()
		self.save()

		return message.as_dict()


# Helper functions

@frappe.whitelist()
def create_from_webhook(data):
	"""
	Create Communication Hub from webhook data.

	Args:
		data (dict): Webhook payload with customer and channel info

	Returns:
		dict: Created Communication Hub document
	"""
	# Find or create customer
	customer = get_or_create_customer(data)

	# Create hub
	hub = frappe.get_doc({
		"doctype": "Communication Hub",
		"customer": customer.name,
		"channel": data.get("channel"),
		"subject": data.get("subject"),
		"elevenlabs_agent_id": data.get("elevenlabs_agent_id"),
		"elevenlabs_conversation_id": data.get("elevenlabs_conversation_id"),
		"elevenlabs_phone_number": data.get("phone_number"),
		"chatwoot_conversation_id": data.get("chatwoot_conversation_id"),
		"social_sender_id": data.get("social_sender_id"),
		"social_platform": data.get("social_platform"),
		"email_from": data.get("email_from"),
		"email_subject": data.get("email_subject"),
		"email_message_id": data.get("email_message_id")
	})
	hub.insert()

	return hub.as_dict()


def get_or_create_customer(data):
	"""Get existing customer or create new one from webhook data"""
	# Try to find by email
	if data.get("email"):
		customer = frappe.db.get_value("Customer", {"email_id": data["email"]}, "name")
		if customer:
			return frappe.get_doc("Customer", customer)

	# Try to find by phone
	if data.get("phone"):
		customer = frappe.db.get_value("Customer", {"mobile_no": data["phone"]}, "name")
		if customer:
			return frappe.get_doc("Customer", customer)

	# Create new customer
	customer_name = data.get("name") or data.get("email") or data.get("phone") or "Guest"

	customer = frappe.get_doc({
		"doctype": "Customer",
		"customer_name": customer_name,
		"customer_type": "Individual",
		"customer_group": "Individual",
		"territory": "All Territories",
		"email_id": data.get("email"),
		"mobile_no": data.get("phone")
	})
	customer.insert()

	return customer
